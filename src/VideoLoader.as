package src{	import flash.display.MovieClip;	import flash.display.SimpleButton;	import flash.display.Stage;	import flash.events.*;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.ObjectEncoding;	import flash.net.Responder;	import flash.utils.Timer;		public class VideoLoader	{		private var playlist:Array;		private var video:Video;		private var videoPlayer:VideoPlayer;		private var nc:NetConnection;		private var ncClient:Object;		private var ns:NetStream;		private var nsClient:Object;		private var nsFrameDelay:Timer;		private var nsDelay:Number = 200;		private var soundXForm:SoundTransform;				private var startBtn:SimpleButton;		private var appStage:Stage;		private var canvasMc:MovieClip;		private var pb:PlaybackControls;		private var initialized:Boolean = false;		public  var isPlaying:Boolean = false;		private var _rtmp:String = "rtmp://fms.servebeer.com";		private var _rtmpDirectory:String;		private var _nsDuration:Number;		private var _nsTime:Number;		private var _currentIndex:Number = 0;		private var _filePath:String;		private var _videoWidth:Number;		private var _videoHeight:Number;		private var _videoAspectRatio:Number;		private var _videoDataRate:Number;				public function VideoLoader( playlist:Array, videoPlayer:VideoPlayer, appStage:Stage )		{			this.playlist = playlist;			this.filePath = playlist[currentIndex].path;			this.rtmpDirectory = playlist[currentIndex].dir;			this.videoPlayer = videoPlayer;			this.appStage = appStage;			this.pb = this.videoPlayer.playBackControls;			this.canvasMc = this.videoPlayer.canvasMc;						video = new Video( canvasMc.width, canvasMc.height );			video.x = canvasMc.x;			video.y = canvasMc.y;					//This a single Persistant connection to the FMS			nc = new NetConnection();			//Change this to ObjectEncoding.AMF0 for FMS2 Servers			nc.objectEncoding = ObjectEncoding.AMF3;			ncClient = new Object();			//I know it looks ugly but it everything worked better with an anonymous function			ncClient.onBWDone = function( info ) { BWDone( info ); }			ncClient.onBWCheck = onBWCheck;			nc.client = ncClient;			//Control the Sound Volume + Initially set it to Zero to be mindful for the nsFrameDelay()			soundXForm = new SoundTransform();			//Set the Volume to 75% even before the NetStream Object has been created			soundXForm.volume = 0.75;						//NetStream Object Handle's CallBacks Made by the Flash Media Server			nsClient = new Object();			nsClient.onMetaData = onMetaData;			nsClient.onPlayStatus = onPlayStatus;			nsClient.onCuePoint = onCue;						//This delay will allow for the first frame of the video to laod						nsFrameDelay = new Timer( nsDelay , 1 );			//Listen to when the Timer is launched so that it can run 200ms and stop near the first frame of the vid			nsFrameDelay.addEventListener(TimerEvent.TIMER_COMPLETE, nsFirstFrameHandler, false, 0, true);						//This is the Large Start Button at the beginning of the video			startBtn = new StartBtn();			startBtn.x = ( (canvasMc.width / 2)  - (startBtn.width / 2)  + canvasMc.x );			startBtn.y = ( (canvasMc.height / 2) - (startBtn.height / 2) + canvasMc.y );			//NetConnection will be made before the user hits the Start button. The start button will basically Resume the playback			startBtn.addEventListener(MouseEvent.CLICK, startHandler, false, 0, true );			//Based on whether the Large Button is on the Main stage, the other Playback Controls will either be activate or inactive			startBtn.addEventListener( Event.ADDED_TO_STAGE, startAddedToStageHandler, false, 0, true );			startBtn.addEventListener( Event.REMOVED_FROM_STAGE, startRemovedFromStageHandler, false, 0, true );			//!!!If there are multiple Videos in a Playlist, the user whould be allowed to toggle through the vids before hitting play			connectHandler( );		} 		/*************************************************************		 * Event Listeners		*************************************************************/		private function startAddedToStageHandler( e:Event ):void		{			trace( "startAddedToStageHandler: " + e.currentTarget );			pb.playPause.deactivateListeners();			pb.progressSlider.deactivateListeners();			pb.volumeControl.deactivateListeners();			pb.skipButtons.deactivateListeners();		}				private function startRemovedFromStageHandler( e:Event ):void		{			trace( "startRemovedFromStageHandler: " + e.currentTarget );			pb.playPause.activateListeners();			pb.progressSlider.activateListeners();			pb.volumeControl.activateListeners();			pb.skipButtons.activateListeners();		}			 		/*************************************************************		 * Basic Event Handlers		*************************************************************/		private function connectHandler( ):void		{			/**********************************************************************************************			 * A. Auto bandwidth checking can be used to understand a users internet connection.			 *   It could be used as a way to serve different web versions if a user has a slower connection speed.			 *	   We are not using it right now because it requires Netconnection.prototype.onBWDone which I am not			 *	   handling from this specific video component. I am handling onBWDone from the Asset Server because 			 *	   an ITEM DETAIL page has the potential to serve Video | Audio | Images.  If you send a request to the FMS			 *	   but in the meantime switch from a video to an image, an error will occure when the FMS responds.  Therefore			 *	   I am handling that specific callback function in Asset Server but it's not yet able to handle onBWDone()			**********************************************************************************************/			//A. Make a NetConnection						createConnection( rtmp + "/" + rtmpDirectory + "/" );		}				private function createConnection( rtmp:String, checkAutoBW:Boolean = false ):void		{			//A. If no NetConnection has yet been made, MAKE ONE!			if(!nc.connected){				//B. Set checkAutoBW = true if you want Automactic Bandwidth Checking				nc.connect( rtmp, checkAutoBW );				//C. Next step is to watch this method netStatusHandler();				nc.addEventListener( AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler, false, 0, true );				nc.addEventListener( NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true );				nc.addEventListener( SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true );			} else {				connectionSuccess( new Event( "NetConnection is Currently Active" ) );			}					}				private function httpErrorHandler( e:HTTPStatusEvent ):void		{			switch ( e.status ) {				case 0:					trace("httpErrorHandler: Internet Connection Down");				break;				case 404:					trace("httpErrorHandler: 404 Error");				break;				default:				break;			}		}				private function securityErrorHandler( e:SecurityErrorEvent ):void		{			trace( "securityErrorHandler: " + e.text );		}				private function asyncErrorHandler( e:AsyncErrorEvent )		{			trace( "asyncErrorHandler: " + e.text );		}				private function ioErrorHandler( e:IOErrorEvent ):void		{			trace( "ioErrorHandler: " + e.text );		}				/*************************************************************		 * PlayBack Event Handlers		*************************************************************/		private function startHandler( e:MouseEvent ):void		{			//A. Resume the Open NetStream Connection or UnPause the video			resumeNs();			//B. Remove the Start Button			appStage.removeChild( startBtn );			//C. Adjust the Volume to 60% of the maximum		}						/*************************************************************		 * NetConnection Event Handlers		*************************************************************/		private function connectionSuccess( e:Event ):void		{			//A. Assign a new NetStream connection			if( ns == null ){				ns = new NetStream(nc);				ns.addEventListener( AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler, false, 0, true );				ns.addEventListener( NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true );				ns.addEventListener( IOErrorEvent.IO_ERROR, ioErrorHandler, false, 0, true );			}			//B. Play the NetStream Connection and Start it on Second 0			playNs(0);		}				private function connectionFailed( e:Event ):void		{			trace("connectionFailed: " + e.type + "\nRetrying...");			connectHandler()		}		private function netStatusHandler( e:NetStatusEvent ):void		{		    switch( e.info.code )			{		        case "NetConnection.Connect.Success":		            //connectionSuccess( new Event( "Success" ) );		        break;		        case "NetConnection.Connect.Failed":		            connectionFailed( new Event( "Failed" ) );		        break;				//A. Reset happens every time a new NetStream is requested.				//B. Every time there's a new NS, make sure the First Frame Displays				case "NetStream.Play.Reset":					nsFrameDelay.start();				break;		        default:		        break;		    }		}			private function onBWCheck( info:Object ):void		{			//trace("SWF_ASSET_MANAGER onBWCheck: " + info );			}				private function BWDone( info:Object ):void		{			if( info ) trace( "Users Bandwidth: " + info );			connectionSuccess( new Event( "onBWDone" ) );				}		/*************************************************************		 * NetStream Event Handlers		*************************************************************/		////////////////////////////////////////////////////////////		//Public		////////////////////////////////////////////////////////////		public function changeNsAsset( direction:int ):void		{			//A. Only Close the Stream if it has actually begun			if( isPlaying ) closeNs();			//B. This will either change the current index to +1 or - 1			currentIndex += direction;						if(currentIndex > playlist.length - 1)			{				currentIndex = 0;			}			else if (currentIndex < 0)			{				currentIndex = playlist.length - 1;			}			//C. Create a new NetStream connection			connectionSuccess( new Event("changeNsAsset(" + direction + ")"));		}		public function pauseNs():void		{			ns.pause();			isPlaying = false;			pb.playMc.gotoAndStop("play");		}				public function resumeNs():void		{			ns.resume();			isPlaying = true;			pb.playMc.gotoAndStop("pause");		}				public function seekNs( offset:Number ):void		{			ns.seek( offset );		}		public function togglePauseNs():void		{			ns.togglePause();			}		////////////////////////////////////////////////////////////		//Private		////////////////////////////////////////////////////////////		private function nsFirstFrameHandler( e:TimerEvent ):void		{			//A. Immediately pause the Video Stream			pauseNs();			//B. Make Sure that the Clock is reset to 0			pb.timecodeTxt.text = "00:00";			//C. Display the Start Button on the Stage			appStage.addChild(startBtn);			//D. The Start button is already being Handled by startHandler()		}		private function playNs( position:Number ):void		{			//A. Reset the Play/Pause button to Play			pb.playMc.gotoAndStop("pause");			//B. Ensure that the connection to FMS is open			if (!nc.connected) { connectHandler(); }			//C. Make sure the vid does not have a file .extension			var pathname:String = checkNsExtension( playlist[currentIndex].path);				//D. Play the new NetStream connection			//play(vidName, postion in Seconds:Number, duration in seconds:Number, flush:Boolean -> false means play the next vid)			ns.bufferTime = 1.5;			//trace("pathname: " + pathname);			ns.play(pathname, position);			//E. Attacth the ns:NetStream to the video:Video			video.attachNetStream(ns);			//F. Assign the nsClient to catch the video's duration and onPlayStatus			ns.client = nsClient;			//G. Adjust the Volume			ns.soundTransform = soundXForm;			//H. Adjust the GUI on volMeterMc so that it reflects the volume			setVol( getVol() );			//J. Retreive the Length of the Song from FMS and set it to nsDuration			nc.call("getStreamLength", new Responder( getStreamLengthHandler ), pathname);			//First time this is announced as True			isPlaying = true;						//L. Check whether the Video Player has already been initialized			if( initialized == false )			{				//1. Load the Play/Pause Button				pb.playPause = new PlayPauseButton( pb.playMc, this);								//2. Load the Progress Bar				pb.progressSlider = new ProgressSlider( pb.seekBarMc, pb.seekScrubMc, this );				//3. Load the VolumeControl				pb.volumeControl = new VolumeControl( pb.volBarMc, pb.volScrubMc, pb.volMeterMc, this);								//4. Load Previous and Next Buttons				pb.skipButtons = new SkipButtons( pb.nextBtn, pb.prevBtn, this );								//5. Load the Full Screen Window Button				pb.fullScreenButton = new FullScreen( pb.fsBtn, appStage, this );				initialized = true;			}		}						private function closeNs():void		{			ns.close();			isPlaying = false;		}		private function nsCompleteHandler():void		{			//A. If your Player is using XML, then it probably is a Playlist therefore it also needs a Next Button			if ( playlist.length > 1 ){				changeNsAsset(1);			} else {			//B. Otherwise close the NetConnection and Restart the Entire Proces, YES IMPROVEMENTS CAN BE MADE HERE				closeNs();				connectionSuccess( new Event("nsCompleteHandler: NetStream Complete"));			}		}		/*************************************************************		 * Flash Media Server Event Handlers		*************************************************************/		//Return all the Video information that comes from the FLV file.  Mp3's don't use Meta Data		private function onMetaData( info:Object ):void		{			if(info.width > info.height)			{				//A. If the FLV is wider than taller, then set the width of the Movie to the Width of the Canvas				videoWidth = canvasMc.width;				videoHeight = info.height;					} else 			{				//B. If the FLV is taller than wider, then set the height of the Movie to mactch the Canvas				videoWidth = info.width;				videoHeight = canvasMc.width;					}			videoDataRate = info.videodatarate;						setVideoAspectRatio(info.width, info.height);						adjustVideo( getVideoAspectRatio() );		}				//This is used to determine when a Video has ended		private function onPlayStatus( obj:Object ):void		{			trace("playStatus: " + obj.code);			switch ( obj.code ){				case "NetStream.Play.Switch":					//The subscriber is switching from one stream to another in a playlist				break;				case "NetStream.Play.Complete":					nsCompleteHandler();				break;						default:					//for( var a:String in obj ){ trace(a + " " + obj[ a ]); }				break;			}		}						private function onCue( obj:Object ):void		{			//trace( info );					}				private function getStreamLengthHandler( info:Number ):void		{			this.nsDuration = info;		}		/*************************************************************		 * Helper Functions		*************************************************************/		////////////////////////////////////////////////////////////		//Public		////////////////////////////////////////////////////////////		//These functions are accessed by VolumeControl		public function setVol( vol:Number ):void		{			soundXForm.volume = vol;			ns.soundTransform = soundXForm;		}				public function getVol():Number		{			return soundXForm.volume;		}		////////////////////////////////////////////////////////////		//Private		////////////////////////////////////////////////////////////		private function checkNsExtension( fileName:String ):String		{			//A. Remove the appended File Extension and Prepend it			switch ( fileName.substr(-4) )			{				case ".flv":					fileName = fileName.slice(0, -4);				break;				case ".mp4":					fileName = "mp4:" + fileName.slice(0, -4);				break;				default:				break;			}			return fileName;		}		private function adjustVideo( ratio:Number ):void		{			//A. Since movies are either Square or Rectangular, we are adjusting the height to match the movies new width			var newVidHeight:Number = Math.round( videoWidth / ratio);			//B. Set the new Height for the Movie			video.height = newVidHeight;			//C. You basically want to Paint this movie on top of the Black Canvas called canvasMc. From there, center it			video.y = ( canvasMc.height - video.height ) / 2 + canvasMc.y;			//D. Once the Video Aspect Ratio has been calculated, find out if the Video has previously been placed			if( appStage.contains( video ) == false ) appStage.addChild( video );		}				/*************************************************************		 * Read / Write Accessors		*************************************************************/		////////////////////////////////////////////////////////////		//Public		////////////////////////////////////////////////////////////		public function get nsTime():Number		{			return ns.time;		}		public function get nsDuration():Number		{			return _nsDuration;		}				public function set nsDuration( length:Number ):void		{			_nsDuration = length;		}		////////////////////////////////////////////////////////////		//Private		////////////////////////////////////////////////////////////		private function get rtmp( ):String		{			return _rtmp;		}				private function set rtmp( path:String ):void		{			_rtmp = rtmp;		}				private function get rtmpDirectory( ):String		{			return _rtmpDirectory;		}				private function set rtmpDirectory( dir:String ):void		{			_rtmpDirectory = dir;		}				private function get currentIndex():Number		{			return _currentIndex;		}				private function set currentIndex( index:Number ):void		{			_currentIndex = index;		}				private function get filePath( ):String		{			return _filePath;		}				private function set filePath( path:String ):void		{			_filePath = path;		}				private function get videoWidth():Number		{			return _videoWidth;		}				private function set videoWidth( width:Number ):void		{			_videoWidth = width;		}				private function get videoHeight( ):Number		{			return _videoHeight;		}				private function set videoHeight( height ):void		{			_videoHeight = height;		}				private function getVideoAspectRatio( ):Number		{			return _videoAspectRatio;		}				private function setVideoAspectRatio( width:Number, height:Number ):void		{			if (width > height) _videoAspectRatio = width / height;			else _videoAspectRatio = height / width;		}		private function get videoDataRate( ):Number		{			return _videoDataRate;		}				private function set videoDataRate( rate:Number ):void		{			_videoDataRate = rate;			}			}}